use std::fs;
use std::path::Path;

static YEAR: &str = "2024";
static DAY: &str = "NN";

fn load_data(example_data: bool, test: bool) -> (Vec<usize>, Vec<usize>) {
    let mut file_name = if example_data {
        format!("input/{YEAR}/{DAY}.example.input")
    } else {
        format!("input/{YEAR}/{DAY}.input")
    };
    if test {
        file_name = format!("../{file_name}");
    }

    let input =
        fs::read_to_string(Path::new(&file_name)).expect("Should have been able to read the file");

    // Process input data
}

fn solve_part_1(example_data: bool, test: bool) -> usize {
    let mut result: usize = 0;
    let data = load_data(example_data, test);

    // Solve part 1

    result
}

fn solve_part_2(example_data: bool, test: bool) -> usize {
    let mut result: usize = 0;
    let data = load_data(example_data, test);

    // Solve part 2

    result
}

fn main() {
    let answer1 = solve_part_1(false, false);
    println!("Answer for part 1: {answer1}");

    // let answer2 = solve_part_2(false, false);
    // println!("Answer for part 2: {answer2}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn example_part_1() {
        let result = solve_part_1(true, true);
        assert_eq!(result, 0);
    }

    // #[test]
    // fn answer_part_1() {
    //     let result = solve_part_1(false, true);
    //     assert_eq!(result, 0);
    // }

    // #[test]
    // fn example_part_2() {
    //     let result = solve_part_2(true, true);
    //     assert_eq!(result, 0);
    // }

    // #[test]
    // fn answer_part_2() {
    //     let result = solve_part_2(false, true);
    //     assert_eq!(result, 0);
    // }
}
